# -*- coding: utf-8 -*-
"""
Created on Sat May 23 12:05:38 2020

@author: 10624
"""
"""
This file contains function shared by all other program files. All functions here are the general functions
"""
import numpy as np
from matplotlib import pyplot as plt
import Basemapset as bm
import seaborn as sns
import pandas as pd
import scipy

def FeatureScaling(A):
    return ((A-np.min(A))/(np.max(A)-np.min(A)))

def FeatureScaling2(A, min_val, sigma_val):
    return ((A - min_val)/sigma_val)

def dist(node1y, node1x, node2y, node2x):
    return ((node1y - node2y)**2+(node1x - node2x)**2)**0.5/1000 #m -> km

def minimumk(sequence, k):
    """return the minimum k elements in the sequence
    """
    list1 = []
    sequence2 = np.sort(sequence)
    for i in range(k):
        element = sequence2[i]
        list1.append(list(sequence).index(element))
    
    return list1

def degreeNdegree(Adjmatrix):
    """Given the adjacent matrix of a network, return the degree and nodal neighborhood degree sequence
    """
    degree = np.sum(Adjmatrix, axis = 1)
    Ndegree = np.zeros(len(degree), dtype = int)
    for i in range(len(degree)):
        Temp = 0
        for j in range(len(degree)):
            Temp += degree[j]*Adjmatrix[i, j]
        Ndegree[i] = Temp
    
    return degree, Ndegree

def scatternetwork(geoloc, supplynum, color, supplyname, demandname):
    """Scatter the facility on the basemap
    """
    plt.scatter(geoloc[0:supplynum, 1], geoloc[0:supplynum, 0], 400, color, marker = '+', label = supplyname)
    plt.scatter(geoloc[supplynum:, 1], geoloc[supplynum:, 0], 100, color, marker = 'o', label = demandname)

    plt.legend(bbox_to_anchor=(1, 1), loc='upper left', ncol=1, fontsize = 25, frameon = 0)
    
    plt.show()
    
def plotnetwork(geoloc, supplynum, color, supplyname, demandname, adjmatrix):
    """Plot the figure of the networks
    """
    plt.scatter(geoloc[0:supplynum, 1], geoloc[0:supplynum, 0], 400, color, marker = '+', label = supplyname)
    plt.scatter(geoloc[supplynum:, 1], geoloc[supplynum:, 0], 100, color, marker = 'o', label = demandname)

    for i in range(len(adjmatrix)):
        for j in range(len(adjmatrix)):
            if(adjmatrix[i, j] == 1):
                plt.plot([geoloc[i, 1], geoloc[j, 1]], [geoloc[i, 0], geoloc[j, 0]], 'black', lw = 1)

    plt.legend(bbox_to_anchor=(1, 1), loc='upper left', ncol=1, fontsize = 25, frameon = 0)
    
def plotdistcompare(list1, list2, list3):
    """Plot the distributions of the two networks generated using different methods
    Input: list1 - features of the network generated using the first method
           list2 - features of the network generated using the second method
           format: [data, color, label, axlabel, color]
           list3 - x and y of the corresponding Shelby County system
    """
    plt.figure(figsize = (10, 6))
    sns.set_style("whitegrid")
    sns.set_context("paper")
    #plt.figure(figsize = (10, 6))
    sns.distplot(list1[0], color = list1[1], label = list1[2], axlabel = list1[3], norm_hist = True, kde = True)
    sns.distplot(list2[0], color = list2[1], label = list2[2], axlabel = list2[3], norm_hist = True, kde = True)
#    sns.distplot(list3[0], color = list3[1], label = list3[2], axlabel = list3[3], norm_hist = True, kde = True)
#    plt.plot(list3[0], list3[1], lw = 5, label = 'the Real network', color = list3[2])
    plt.legend(bbox_to_anchor=(1, 1), loc='upper right', ncol=1, frameon = 0)

def plotboxcompare(real, list1, list2, key1, key2):
    """Plot the boxplot using seaborn to compare the feature values of networks generated using method1, method2 and real network
    Input: real - the feature values of three real networks: Water, Power and Gas
           list1 - feature values of networks generated by method1
           list2 - feature values of networks generated by method2
           key1 - ['Method1', 'Method2', 'The real network']
           key2 - ['Water', 'Power', 'Gas']
    """
    templist = list2dataframe([list1, list2], real, key1, key2)
    frame = pd.DataFrame(templist, columns = ['Method', 'Infrastructure', 'Value'])
    plt.figure(figsize = (14, 8))
    sns.boxplot(x = 'Infrastructure', y = 'Value', hue = 'Method', data = frame)
    plt.legend(bbox_to_anchor=(1, 1), loc='upper right', ncol=1, frameon = 0)
    
def statistical_analysis(valuename, value1, value2, value, color, num, key1, key2):
    """Statistical analysis of the network topology with boxplot and distribution plot in terms of comparison the three networks
    Input: valuename - the name of the value to be plot
           valuex - value calculated using the xth method
           value - the topology feature of the real network
           color - color to plot the figure
           num - the number of differernt methods
    Output: the boxplot and the distribution plot of certain feature of the network topology
            average, standard deviation and the coefficient variance of the specified network topology
    """
    
    Method_name = []
    ave1, std1, cv1 = [], [], []
    ave2, std2, cv2 = [], [], []
    
    for i in range(num):
        Method_name.append('Method{}'.format(i + 1))
        
    for i in range(num):
        plotdistcompare([value1[i], color[i][0], Method_name[0], valuename], [value2[i], color[i][1], Method_name[1], valuename], [[value[i]]*max(len(value1[i]), len(value2[i])), color[i][2], Method_name[2], valuename])
        
        ave1.append(np.mean(value1[i]))
        ave2.append(np.mean(value2[i]))
        
        std1.append(np.std(value1[i]))
        std2.append(np.std(value2[i]))
        
        cv1.append(scipy.stats.variation(value1[i]))
        cv2.append(scipy.stats.variation(value2[i]))
        
    plotboxcompare(value, value1, value2, key1, key2)
    
    return ave1, ave2, std1, std2, cv1, cv2
        
        
        
    
    


def Removeinf(list1):
    """Remove the element of infinity value in the list1
    """
    import math
    
    list2 = []
    for i in range(len(list1)):
        if(list1[i] == math.inf):
            continue
        list2.append(list1[i])
    
    return list2

def list2dataframe(List, value, key1, key2):
    """Convert two lists of cost to dataframe
    Input: List = [list1, list2] - list of values of certain variables in first and second variables
           Value - the variable value of the real network
           key1 - ['Method1', 'Method2', 'The real network']
           key2 - ['Water', 'Power', 'Gas']
    Output: dataframe
    """
    mylist = []
    for i in range(len(List)):
        for j in range(len(List[i])):
            for k in range(len(List[i][j])):
                mylist.append([key1[i], key2[j], List[i][j][k]])
    
    for i in range(len(value)):
        mylist.append([key1[2], key2[i], value[i]])
    
    return mylist


    

#def decompose(degree, d):
#    """Given the number of the total degree and the number of vertices, output the degree list
#    """
#    import math
#    
#    degreelist = np.zeros(d)
#    temp = math.floor(degree/d)
#    Temp = 0
#    for i in range(d - 1):
#        if(i%2 == 0):
#            degreelist[i] = temp
#            Temp += temp
#        else:
#            degreelist[i] = temp + 1
#            Temp += temp + 1
#            
#    degreelist[-1] = degree - Temp
#    print(degreelist)
#    
#    return degreelist
